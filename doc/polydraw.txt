CDG NOTE: Original polydraw README, see main top-level README for updated information.

--

PolyDraw
An OpenGL/GLSL scripting tool

Get the latest version here:
   http://advsys.net/ken/download.htm#polydraw

Authors:

   Ken Silverman (http://advsys.net/ken):
      EVAL compiler, GUI cleanup, fixes, enhancements

   Tigrou (tigrou.ind@gmail.com):
      Original author & concept.
      His original release on January 2, 2010 can be found here:
         http://pouet.net/prod.php?which=54245
         ftp://ftp.untergrund.net/users/ind/polydraw.zip


Texture sources:
   kensky.jpg: Generated by Ken using Terragen v0.9
   earth.jpg: based on earthmap1k.jpg from:
      http://planetpixelemporium.com/earth.html
   b2dr_sph.jpg: Converted by Ken from a computer generated scene which was
      designed by Dennis Radon.
   skytest.png: Drawn by Ken to show face order for skyboxes.

-------------------------- Early History by Tigrou  --------------------------

(Fixed&updated by Ken)

I started this project during winter 2007. I always dreamed about a tool that
allowed me to directly type OpenGL commands to try things without having to
use a compiler - same for pixel shaders. At that time I was really bored to
have to start VC6, then download an OpenGL framework and spend time with
libraries and linker errors in order to try something. Pixel and vertex
shaders were even worse as the initial frameworks are even bigger and
debugging them is quite painful.

Basically I needed:
1. A script interpreter or compiler fast enough to make OpenGL calls in real
   time. Something that runs at 8 fps for drawing a simple 3d cube would have
   been totally useless.
2. An interface with 2 windows: one to edit code, and another for quick
   preview.

Unfortunately the amount of work needed to write a code interpreter, debug it,
and link all the stuff with OpenGL seemed *enormous*. At that time I couldn't
afford to spend 6-12 months developing a tool like this.

Then I found the EVAL library by Ken Silverman (http://advsys.net/ken), which
allowed me to save a lot of time. The EVAL library is really nice to use, fast
and reliable. Within a few days, I had a working tool with almost all of the
features I wanted. I used it for some projects in the past and now I have
decided to share it with the demoscene community.

I have decided to provide full source code. You may use this program and its
source however you wish as long as you respect two things:
1. You distribute it free of charge. Commercial use is prohibited.
2. You preserve credit. Please make sure a copy of our names and download
sites are available. Including this text file is sufficient.

We have included many sample scripts to try. You should look through them to
see what this tool can do. You may notice that some scripts have errors. These
can happen due to slight differences in each graphics card driver. Usually
they are minor syntax errors that can be fixed pretty quickly.

If this program is helpful to anyone, we would be happy to hear about it.

Tigrou
tigrou.ind@gmail.com
-------------------------- Additional words by Ken  --------------------------

Tigrou alerted me to his PolyDraw in January 2010, when he released it on
pouet.net. I was excited to see someone else use my EVAL library. Also his
demo scripts were impressive. I had never done shader programming before, and
so I didn't do much with it at the time.

6 months later, I was reading about shaders. I remembered Tigrou's PolyDraw,
and started to look at it more seriously. I cleaned up his GUI a bit and
learned just enough GLSL to port 3 old Evaldraw scripts (CEILFLOR2, DRIFTBOX,
INTERFERENCE) to PolyDraw. I sent Tigrou a demo and then went back into
hibernation.

6 more months pass. One day, I was wondering if a pixel shader could be used
to render a sphere by superscribing a polygon around the ellipse and using the
shader to reject pixels outside the boundary. I soon discovered the discard
statement. (Before I thought this could only be done with lots of polygons.)
Once I got a working drawsph() function using shaders, I was hooked. Over the
next 3 months, I added a lot more features to feed my curiosity.

For me, PolyDraw has been a great platform to learn GLSL programming. It's
not a perfect tool, but with support for scripting OpenGL code, it's a lot
more powerful than other tools. Many of the demos would not have been possible
without this functionality.

------------------------------- Ken's changes  -------------------------------

Summary of major changes:
* Textures now can be loaded from file or generated from EVAL (glsettex)
* Multitexture now supported (glactivetexture)
* Back-face culling between vertex&fragment shader now supported (glcullface)
* Now support keyboard/mouse interation, and better timer.
* Now support 1D, 3D, and cube (skybox) textures (glsettex).
* Support multiple Vertex shaders, Geometry shaders, specify shader by name.

GUI:
* New window layout with hotkey (Alt+Enter) to toggle maximized render window.
* Add menus & font selection.
* Text editor now supports insert/overwrite mode, multi-indent, find&replace.
* New ASCII-compatible file format (*.PSS); scripts now written in 1 window.
* Show line numbers; highlight line of errors.
* New option: Compile on Ctrl+Enter.
* Highlight text expression and press Ctrl+'=' to evaluate immediately to log.
* Show frame rate in title bar.
* Save options to POLYDRAW.INI.

New GL functionality:
* Extend glsetshader(), glcapture()
* Add constants for glBegin() (i.e. GL_QUADS, etc..)
* Add glsettex(), glgettex(), glactivetex()
* Now support all dimensional variants of glVertex(), glTexCoord(), glColor()
* Add glGetUniformLoc(), glUniform(), glGetAttribLoc(), glVertexAttrib()
* Add control of texture filter & wrapping modes.
* Add glCullFace()
* Add glswapinterval(), glklockstart(), glklockelapsed().
* Add gluPerspective(), glBlendFunc(), glEnable/glDisable(GL_DEPTH_TEST).
* Fallback code to use old function names (glCreateShaderObjectARB, etc.).
* Support ARB assembly.

New general functions:
* Add rgb(), rgba(), noise()
* Add printf(), printg(), srand()
* Add playnote(), mountzip()
* Add xres, yres, mousx, mousy, bstatus, keystatus[]
* Add klock(), numframes
* Add sleep()

Misc:
* Implement freeze protection for EVAL script.
* Implement auto-restart and try-exception to catch shader compiler issues.
* Increase number of user textures from 4 to 256.
* Fix some memory leaks.
* Remove rarely used sound script.
* Many new example scripts in \ken directory

----------------------------------- Manual -----------------------------------

PolyDraw has 3 windows:
1. A render window that shows your program output.
2. A console window which displays a read-only log of compile errors and
   general messages. You can write custom messages to the log using printf().
3. A code window, which must contain at least 3 blocks:
      1. The host script; compiled with the in-memory EVAL compiler.
      2. A vertex shader.
      3. A fragment (pixel) shader.
Geometry shaders are also supported, but they are optional.

You must put the following line of code before each vertex shader:
   @v

You must put the following line of code before each geometry shader:
   @g

You must put the following line of code before each fragment (pixel) shader:
   @f

By default, the code at top is the host script. If you wish to relocate the
host code, you may put the following line of code before it:
   @h
Note that only 1 host block is allowed - whichever comes last in the file.

Here is an example of a minimalistic, yet complete script:
   ---------------------------------------------------------------------------
   glquad(1); //"C" program
   @v
   void main () { gl_Position = ftransform(); } //Vertex shader
   @f
   void main () { gl_FragColor = vec4(gl_FragCoord*.001); } //Fragment shader
   ---------------------------------------------------------------------------

When using multiple shaders, it is a good idea to name them. The syntax is:
   @v(:name)
   @g(:name)
   @f(:name)
   @(:name)  //next block is same type (v/g/f) as previous.

Example:
   ---------------------------------------------------------------------------
   glsetshader("vert","frag0"); glquad(1); //Host script
   glsetshader("vert","frag1"); glquad(1);
   @v:vert   //double forward slash comments are allowed here..
   void main () { gl_Position = ftransform(); } //Vertex shader
   @f:frag0  //..and here
   void main () { gl_FragColor = vec4(gl_FragCoord*.001); }//Fragment shader 0
   @f:frag1
   void main () //Fragment shader 1
   {
      if (gl_FragCoord.x+gl_FragCoord.y > 200) discard; //draw bot-left corner
      gl_FragColor = vec4(.9,.9,.5,0); //yellow
   }
   ---------------------------------------------------------------------------

For a geometry shader, you must specify primitive I/O types and max vertices.
You may do that with the following syntax:
   @g,GL_TRIANGLES,GL_TRIANGLE_STRIP,1024:myname
   #version 120
   ...

If you select shader version >= 1.50, you may put these inside the script:
   @g
   #version 150
   #extension GL_EXT_geometry_shader4 : enable
   layout(triangles) in;
   layout(triangle_strip, max_vertices = 6) out;
   ...

------------------------------------------------------------------------------
Color mode parameter (last parameter of glsettex()/glgettex()/glcapturetex()):

There are 3 types of constants that may be added together:

1. Color type constant:
                 eval/host OpenGL/GPU
                 vals/pix: bytes/pix:   Description:
      KGL_BGRA32     1          4       32-bit color as 1 value (0 .. 2^32-1)
      KGL_SHORT      1          2       one  16-bit short  per pixel
      KGL_INT        1          4       one  32-bit int    per pixel
      KGL_FLOAT      1          4       one  32-bit float  per pixel
      KGL_VEC4       4         16       four 32-bit floats per pixel

   These examples show how to prepare host arrays for each color mode. They
   generate a 2x2 checkerboard with either a red or white pixel at the
   top-right corner, and the rest black:

      static buf0[4] = {0,0xff0000,0,0};
      glsettex(0,buf,2,2,KGL_BGRA32);

      static buf1[4] = {0,65535,0,0};
      glsettex(0,buf,2,2,KGL_SHORT);

      static buf1[4] = {0,1,0,0};
      glsettex(0,buf,2,2,KGL_FLOAT);

      static buf2[16] = {0,0,0,0, 1,0,0,0, 0,0,0,0, 0,0,0,0};
      glsettex(0,buf,2,2,KGL_VEC4);

2. Texture filter:
   KGL_LINEAR (default), KGL_NEAREST, KGL_MIPMAP (KGL_MIPMAP0 .. KGL_MIPMAP3)
   NOTE: Mip-mapping is only supported for 2D textures.
   NOTE: KGL_MIPMAP is an alias for KGL_MIPMAP3 (GL_LINEAR_MIPMAP_LINEAR)

3. Texture wrap:
   KGL_REPEAT, KGL_MIRRORED_REPEAT, KGL_CLAMP, KGL_CLAMP_TO_EDGE
   NOTE: Cube textures always use KGL_CLAMP_TO_EDGE.

------------------------------------------------------------------------------
Here is a list of PolyDraw functions and variables available in the first
section (i.e. the C program):

glBegin(mode);       Same as OpenGL. The following constants may be used:
                        GL_POINTS, GL_LINES, GL_LINE_LOOP, GL_LINE_STRIP
                        GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN
                        GL_QUADS, GL_QUAD_STRIP, GL_POLYGON
glEnd();             Same as OpenGL.

glVertex(x);         Same as OpenGL. Parameters are floating point. (1D-4D)
glVertex(x,y);
glVertex(x,y,z);
glVertex(x,y,z,w);

glTexCoord(u,v);     Same as OpenGL. Parameters are floating point. (2D-4D)
glTexCoord(u,v,p);
glTexCoord(u,v,p,q);

glColor(r,g,b);      Same as OpenGL. Parameters are floating point. (3D/4D)
glColor(r,g,b,a);

glNormal(x,y,z);     Same as OpenGL. Parameters are floating point. (3D)

hand = glGetUniformLoc("name"); Get handle to shader variable name.
glUniform(hand,val);       Write specified value to shader uniform variable.
glUniform(hand,num,buf);   Write num values to shader uniform array.

hand = glGetAttribLoc("name");   Get handle to vertex shader variable name.
glVertexAttrib(hand,val);  Write specified value to vertex shader attribute
                           variable.

glProgramLocalParam(ind,v0,v1,v2,v3);  Write values to ARB ASM shader.
glProgramEnvParam(ind,v0,v1,v2,v3);    "

glPushMatrix();      Same as OpenGL.
glPopMatrix();       "
glMultMatrix(mat);   "
glTranslate(x,y,z);  "
glRotate(deg,x,y,z); "
glScale(x,y,z);      "
gluLookAt(x,y,z,px,py,pz,ux,uy,uz); "
gluPerspective(,,,); "
setfov(90);          Left-right field of view in degrees.

glcapture(size);     Prepares scene projection settings for render to texture.
                     256 textures are available, starting at index 0. Example:
                        glcapture();
                        //draw stuff
                        glendcapture(0); //copy to texture 0 and clear screen.
                        glquads(); //Render texture 0 (you may use a fragment
                                   //shader to modify the rendering)
                     An optional parameter may be specified to limit the size
                     of the render area. (Default:512) NOTE:high values will
                     be limited by the current render window size.
glcapture(txind,xsiz,ysiz,colmode);
                     Specify rectangular texture size and color mode for
                     capture. See info above about colmode.
glcaptureend(txind); Call once after glcapture() to copy scene to texture.
                     Renders scene using glcopytotexture() then calls glclear.

glsettex(txind,"wood.png"); Load to texture index from file
                            Supported formats: PNG/JPG/GIF/BMP/TGA/PCX/CEL/DDS
                     NOTE:Any texture with exactly 1x6 aspect ratio will be
                     loaded and treated as a cube texture. See KEN\CUBETEX.PSS
                     for an example.
glsettex(txind,buf1d,xsiz,colmode);
glsettex(txind,buf2d,xsiz,ysiz,colmode);
glsettex(txind,buf3d,xsiz,ysiz,zsiz,colmode);
                     Load to texture index from EVAL array. 1D/2D/3D/Cube
                     textures supported. See info above about colmode.
glgettex(txind,buf3d,xsiz,ysiz,colmode);
                     Copy texture from GPU to CPU (host code).

glquad(mode);        Draw full screen quad. Use glquad(0) to use alpha or
                        glquad(1) to fill opaque.
glBindTexture(txind); Select active texture index.
glActiveTexture(unit); Select multitexture unit: GL_TEXTURE0 .. GL_TEXTURE0+3.
                     Example: glActiveTexture(GL_TEXTURE0);
glTextDisable();     Disable textures
glCullFace(mode);    Valid mode constants: GL_NONE, GL_FRONT, GL_BACK,
                        GL_FRONT_AND_BACK

glLineWidth(size);   Same as OpenGL.
glAlphaEnable();     Enable alpha and disable GL_DEPTH_TEST.
glAlphaDisable();    Disable alpha and enable GL_DEPTH_TEST.
glBlendFunc(,);      Same as OpenGL. Standard constants supported.
glEnable();          Only flag supported is: GL_DEPTH_TEST.
glDisable();         "

glSetShader(fragind); Set active fragment shader when using multiple fragment
                     shaders. First index is 0. Vertex shader is always the
                     first one and geometry shader is disabled. (deprecated)
glSetShader("vnam","fnam");        //specify active shader scripts by name.
glSetShader("vnam","gnam","fnam"); //same as above, but with geometry shaders.

klock() or klock(0)  Returns time in seconds since compile of EVAL program.
klock(+1 to +9)      Returns local time.
klock(-1 to -9)      Same as above (when negated), except returns UTC time.
                     Description of options:
                        1:Full date&time, formatted as: YYYYMMDDHHMMSS.sss
                        2:Year{1601-32767}, 3:Month{1-12}, 4:dayofweek{0-6},
                        5:Day{1-31}, 6:Hour{0-23}, 7:Min{0-59}, 8:Sec{0-59},
                        9:millisec{0-999}
                     If synchronization of fields is important, use klock(1)
                     or klock(-1) and extract the components yourself. Ex:
                        t=klock(1); min=int(t/1e2)%100; sec=int(t/1e0)%100;

glklockstart()       Uses GL_???_timer_query extension for accurate timing
                        on the GPU. This function starts your stopwatch.
glklockelapsed()     This function returns the GPU time in seconds since the
                        last call to glklockstart().

numframes            Number of frames rendered since compile of EVAL program.

xres / yres          Current width and height of render window in pixels.
                        These are updated when user resizes window.
mousx / mousy        Position of mouse cursor relative to top-left corner of
                        render window.
bstatus              Mouse button status: Bit 0: Left mouse button
                                          Bit 1: Right mouse button
                                          Bit 2: Middle mouse button
                     Bstatus is updated between frames or during refresh().
                     Bits are updated when their corresponding up/down state
                     changes. A click can be detected like this:
                        if (bstatus%2) { bstatus--; /*left button hit*/ }

keystatus[256]      The status of keys, indexed by their scancode. Array
                    values are written between frames when their key state
                    changes (from pressed to released or vice versa). A key
                    press can be detected like this:

                        if (keystatus[0xc8])
                           { keystatus[0xc8] = 0; playnote(0x90,60,64); }

                     Commonly used scancodes:
                        0xc8:Up       0xd0:Down
                        0xcb:Left     0xcd:Right
                        0x2a:L.Shift  0x36:R.Shift
                        0x1d:L.Ctrl   0x9d:R.Ctrl
                        0x38:L.Alt    0xb8:R.Alt
                        0xc9:PageUp   0xd1:PageDn
                        0xc7:Home     0xcf:End
                        0x52:'0' on keypad

                     NOTE: For keys to work, you must click the render window
                     to gain focus first.

rgb(r,g,b);          Convert 3 value color to single value 24-bit color
                        (0 to 2^24-1). Clips values to {0-255}.
rgba(r,g,b,a);       Same as above, but to 32 bit color including alpha.

noise(x);            An interesting procedural texture function written by
noise(x,y);             Tom Dobrowolski (http://ged.ax.pl/~tomkh)
noise(x,y,z);

printf(fmt,..);      Similar to printf in the C library, with restrictions for
                        safety. Supported types: %e, %E, %f, %g, %G   Writes
                        string to debug console. Use of \r is suggested.
printg(x,y,col,fmt,..); Same as printf() above, but draws text to graphics
                     window instead. Font is always 6x8.

srand(seed);         Sets the random seed for EVAL's internal functions:
                        RND and NRND.
Sleep(msec);         Calls the Windows Sleep() function. Input parameter is
                        time in milliseconds. Calling sleep(1); once per frame
                        is a simple way to save battery life on a laptop (the
                        downside being not perfectly smooth fps)
glSwapInterval(v);   0=Do not limit GPU rendering to vertical retrace.
                        1=default, 2+=slower frame rate.
playnote(cmd,dat1,dat2); Sends a MIDI command to the default MIDI output
                        device. Common MIDI command examples:
                          playnote(0xc0,80,0); //Set instrument, channel 0
                          playnote(0x90,60,64); //Play middle C, channel 0
                          playnote(0x99,36,64); //Play bass drum
                          playnote(0xb0,0x7b,0); //All notes off, channel 0

mountzip("data.zip"); Makes all files inside the specified ZIP file appear as
                        if they are regular files in the local directory. If
                        duplicates are found, the stand-alone file takes
                        precedence. Can also mount directories. The search
                        order for any file accessed is:
                           1. Stand-alone file in .PSS script's directory
                           2. Mounted ZIPs
                           3. Mounted directories
------------------------------------------------------------------------------
Several variables and functions have been deprecated from Tigrou's version.
Here is a list of conversions:

   old       | new
   ----------+------------------------------
   t         | klock()*1000
   global[0] | static global[0], hglobal; hglobal = glgetuniformloc("global");
             |    gluniform1f(hglobal,global[0]);
   fov=a     | setfov(atan((a*PI/360)/atan(yres/xres))*360/PI);   or:
             | gluPerspective(a,yres/xres,.1,1000);
   debug(a); | printf("%f",a);

As a quick hack, you may copy&paste this snippet of code to your script:
   --------------------
   static t, global[16];
   ()
   {
      t = klock()*1e3; setfov(62.79);
      gluniform1fv(glgetuniformloc("global"),16,global);
      ..
   --------------------

-------------------------------- Eval syntax  --------------------------------
Syntax for the host program is very similar to C. The following is an excerpt
from the EVAL library documentation:

Currently supported operators, functions, and statements:

   Parenthesis: (), Arrays: [], Blocks: {}, Const strings: "", Literal '"': \"
          Assignment: = *= /= %= += -= ++ -- (only 1 allowed per statement)
   1-Param Operators: + - . 0 1 2 3 4 5 6 7 8 9 E PI NRND RND (variable names)
   2-Param Operators: ^ * / % + - < <= > >= == != && ||
   1-Param Functions: ABS ACOS ASIN ATAN ATN CEIL COS EXP FABS FACT FLOOR INT
                      LOG SGN SIN SQRT TAN UNIT
   2-Param Functions: ATAN2 FMOD LOG MIN MAX POW
          Statements: IF(expr){codetrue}
                      IF(expr){codetrue}ELSE{codefalse}
                      DO{code}WHILE(expr);
                      WHILE(expr){code}
                      FOR(precode;expr;postcode){code}
                      GOTO label;
                      RETURN expr;
                      BREAK;
                      CONTINUE;
                      ENUM{name(=expr),name(=expr),...};
                      STATIC name[expr]["...],name["],...;
                      label:
            Comments: // text (CR), /* text */

EVAL syntax is similar to C syntax, with the following differences:

Variables & arrays:
 * Function and variable names are case insensitive
 * Type declarations are not allowed in the function body. All variables are
      assumed to be 'double'
 * The size of a static array declaration must be a constant or enum name
 * Strings cannot be in a variable yet. Only the direct form "" is supported
 * EVAL uses bounds checking for arrays (to protect EVALDRAW from crashing
      constantly). The algorithm depends on the array size:
     Power of 2: index is masked using bitwise 'and' causing wrap-around
           Else: out of bounds indices are changed to 0 before the read/write

Built-in functions:
 * PI is a built-in constant: 3.14159265358979323...
 * RND is a parameterless function returning a uniform random number [0..1)
 * NRND is a parameterless function returning a normal random number
      (mean = 0, standard deviation = 1)
 * '^' is a power operator (not an exclusive or). You can also use POW(,)
 * ATN is an alias for ATAN
 * MIN&MAX are usually defined in C headers; here they are library functions
 * LOG supports both 1 and 2 parameter forms. The 2nd paramter is the base
 * INT rounds towards 0. Use FLOOR&CEIL to round towards -/+inf
 * SGN returns -1 for negative numbers, 1 for positive numbers, 0 for 0
 * UNIT returns 0 for negative numbers, 1 for positive numbers, .5 for 0
 * FACT doesn't exist in C. It calculates factorials using the gamma function

Misc.:
 * Switch statements are not yet supported
 * Array initializer lists (ex: static a[3] = {2,3,5};) not yet supported

Function style:
 * The main function must be at the top of the code and have no name
 * The last expression is the return value and doesn't need a ;
 * Return values are optional. If omitted, the function returns 0.0
 * For a 1-function script, the {} around the function body is optional. For a
      multi-function script, you must use {} around every function body.
 * Function parameters can be of type: double, double *, or char *.

------------------------------------------------------------------------------
